import bodyParser from 'body-parser';
import { extractCritical } from 'emotion-server';
import express from 'express';
import expressStaticGzip from 'express-static-gzip';
import helmet from 'helmet';
import path from 'path';
import PrettyError from 'pretty-error';
import * as React from 'react';
import { CookiesProvider } from 'react-cookie';
import * as ReactDOM from 'react-dom/server';
import { Provider } from 'react-redux';
import cookiesMiddleware from 'universal-cookie-express';
// @ts-ignore file generated by webpack in dev and prod
import chunks from './chunk-manifest.json';
import App from './components/App';
import ErrorPage from './components/ErrorPage/ErrorPage';
import Html from './components/Html';
import config, { setupConfigSource } from './config';
import { redirects } from './redirects';
import { initialState } from './reducers/rootReducer';
import { setRuntimeVariable } from './reducers/runtime';
import router from './router';
import configureStore from './store/configureStore';

const app = express();

global.navigator = global.navigator || {};
global.navigator.userAgent = global.navigator.userAgent || 'all';

//
// Register Node.js middleware
// -----------------------------------------------------------------------------

app.use(helmet());

app.use('/', expressStaticGzip(path.join(__dirname, 'public'), { index: false }));
app.use(cookiesMiddleware());

app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());
app.disable('x-powered-by');

if (__DEV__) {
  app.enable('trust proxy');
}

app.get('/_healthcheck', (_, res) => {
  res.status(200).send('OK');
});

//
// Register server-side rendering middleware
// -----------------------------------------------------------------------------
app.get('*', async (req, res, next) => {
  try {
    const { path: pathname, headers, universalCookies, query } = req;

    const host = headers.host;
    const protocol = 'https:';

    // Note: headers.cookie may not exist when in e.g. private browsing
    // so we need to allow for that situation
    const store = configureStore(
      {
        ...initialState,
      },
      {
        cookie: headers.cookie || {},
      }
    );

    store.dispatch(
      setRuntimeVariable({
        name: 'initialNow',
        value: Date.now(),
      })
    );

    const css = [];

    // Global (context) variables that can be easily accessed from any React component
    // https://facebook.github.io/react/docs/context.html
    const context = {
      // Enables critical path CSS rendering
      // https://github.com/kriasoft/isomorphic-style-loader
      insertCss: (...styles: Array<{ _getCss: () => {} }>) => {
        styles.forEach(style => css.push(style._getCss()));
      },
      // Initialize a new Redux store
      // http://redux.js.org/docs/basics/UsageWithReact.html
      store,
    };

    const route = await router.resolve({
      ...context,
      host,
      pathname,
      query,
      protocol,
    });

    if (redirects[pathname]) {
      route.redirect = redirects[pathname];
      route.status = 301;
    }

    if (route.redirect) {
      const redirectStatus = route.status || 302;
      res.redirect(redirectStatus, route.redirect);
      return;
    }

    const data = { ...route };

    const Root = () => (
      <CookiesProvider cookies={universalCookies}>
        <Provider store={store}>
          <App context={context}>{route.component}</App>
        </Provider>
      </CookiesProvider>
    );

    // Here is where we actually render the page content to be passed to <Html/>
    const Emotion = extractCritical(ReactDOM.renderToString(<Root />));

    data.children = Emotion.html;
    css.push(Emotion.css);

    data.styles = [{ id: 'css', cssText: css.join('') }];

    const scripts = new Set();
    const styleLinks = new Set();
    const addChunk = (chunk: string) => {
      if (chunks[chunk]) {
        chunks[chunk].forEach((asset: string) => {
          if (!asset.endsWith('.css')) {
            scripts.add(asset);
          }
          if (asset.endsWith('.css')) {
            styleLinks.add(asset);
          }
        });
      } else if (__DEV__) {
        throw new Error(`Chunk with name '${chunk}' cannot be found`);
      }
    };
    addChunk('client');

    if (route.chunk) {
      addChunk(route.chunk);
    }
    if (route.chunks) {
      route.chunks.forEach(addChunk);
    }

    data.scripts = Array.from(scripts);
    data.styleLinks = Array.from(styleLinks);

    // Get a FRESH copy of the state
    data.state = store.getState();

    setupConfigSource();
    data.config = config.exportKeys.map(key => ({ [key]: process.env[key] })).reduce((acc, curr) => ({ ...acc, ...curr }));

    const html = ReactDOM.renderToStaticMarkup(<Html {...data} />);

    const responseStatus = route.status || 200;
    res.status(responseStatus);

    res.send(`<!doctype html>${html}`);
  } catch (error) {
    console.log(error);
    next(error);
  }
});

//
// Error handling
// -----------------------------------------------------------------------------
const pe = new PrettyError();
pe.skipNodeFiles();
pe.skipPackage('express');

app.use((err: Error, _REQ: express.Request, res: express.Response, _NEXT: express.NextFunction) => {
  const { html: errorHtml, css } = extractCritical(ReactDOM.renderToString(<ErrorPage error={err} />));

  const html = ReactDOM.renderToStaticMarkup(
    <Html title="Internal Server Error" description={err.message} styles={[{ id: 'css', cssText: css }]}>
      {errorHtml}
    </Html>
  );
  res.status(500);
  res.send(`<!doctype html>${html}`);
});

//
// Launch the server
// -----------------------------------------------------------------------------
if (!module.hot) {
  app.listen(config.port, () => console.log(`The server is running at http://localhost:${config.port}/`));
}

//
// Hot Module Replacement
// -----------------------------------------------------------------------------
if (module.hot) {
  // @ts-ignore could not overwrite `core.Express`
  app.hot = module.hot;
  // @ts-ignore could not overwrite `core.Express`
  module.hot.accept('./router');
}

export default app;
